{"name":"Simple-compiler","tagline":"Compiler","body":"# Simple compiler project \r\ngilzalc\r\namichaiv2\r\n\r\n## File description\r\nPackages and java files of Ex6:\r\n\r\n## oop.ex6.blocks:\r\nThis package is composed of an abstract class of a block of codes (AKA scope), with the concrete blocks of the\r\nS-java program,that are the Global, Method, IfWhile that serves for both if condition or a while loop, and a\r\ngeneral ScopeException that represents the exceptions of the blocks.\r\n\r\n## oop.ex6.regexs:\r\nA package that centers all of the methods that uses regular expressions for manipulating text,and also includes\r\na special inherited classes, MethodRegex and VariableRegex for special use in method or variable lines,\r\nrespectively.\r\n\r\n## oop.ex6.parsers:\r\nPackage that holds the parsers for all of the scopes,and one parser (FileParser) that parses\r\nall over the file, creates the different parser of the program, and gives them provides them their code lines.\r\nEach one of them (excluding the FileParser inherit from the super and abstract class \"Parser\", that has the\r\ngeneral methods that each parser uses. This package also holds various Exception files, that all are sub\r\nclasses of a general ParserException class.\r\n\r\n\r\n## oop.ex6.main:\r\nPackage with the main class of the program, Sjavac, that receives a file as an argument, and prints the\r\ncorresponding return value. also has an IllegalSFile exception class, that refers to any exceptions the\r\nprogram has found during the compiling process (excluding IO exceptions).\r\n\r\n## Classes:\r\nKeywords: An abstract class that represents the special keywords that are defined in the s-Java language.it is\r\ncomposed of two enums, one for the Variable types, and one (General) for the others.\r\nManager: Manages the flow of the parsing process.\r\nSreader: A wrapper class for the Buffered reader object\r\nVariable: Represents a specific variable object of the s-Java program.\r\n \r\n# Design\r\nWe have divided the program's tasks, for a small units of responsibility, according to the modularity\r\nprinciples. sometimes we used some hierarchy in the classes, especially in\r\nthe Parsers and the blocks package of classes, because of the similarity of the parsers and blocks, and the\r\nfact  that some extends others in a way, so we could minimize the code duplication, and\r\nimplement the Open/close principle, because the code now can be extended to another type of a scope of\r\nprogram lines very easily and intuitively.\r\n\r\nIn addition, we chose to design the Global scope and the global scope parser making a use of the singletons\r\ndesign pattern, so we can make the program full-safe in the future, since the fact that each program has just\r\none global scope.\r\n\r\nSince we know all of them during the compiling process, the keywords is represented in the code as two enums,\r\none for the Variable types, and another one for the  other general keyword,both placed in an abstract class\r\nthat has a method, which returns a list of all of the String representations of the words. this way we managed\r\nto separate the objects from the rest of the code, and make an addition of another variable type or other\r\nkeyword very facile.Working with enums made the program very open-closed and singled-choice, since extending\r\nthe program in many regards, only means expanding the related enum, as we described at the answers to question\r\npart.\r\n\r\nWe also kept on our mind the Encapsulation and the single-Responsibility principle, so we created a manager\r\nclass that is responsibility is to manage the parsing process of the scopes, and the Regex classes, which only\r\ndeals with the complexity of manipulating Strings using regular expressions, using java util's Matcher and\r\nPattern class. In this way we followed with the principles of the modular design -\r\nwe decomposes the problem into a number of less complex sub-problems- which is a modular decomposability,\r\nand then connected them back at the manager and the sjavac class main method. Of course we are not obligating\r\nthe extension of the code to follow this pattern, according to the importance of the composability - cause we\r\nproduced a software elements which may be freely combined with each other to produce new systems.\r\nthe design of the exceeptions mechansim is explained on the answers section\r\n\r\n## Implementation details\r\n\r\nSince we do not care about the contents of a valid comment line, or a general string of spaces(of course some\r\nspaces matters and we checked them separately), we decided to first parse the file and get rid of all of the\r\ncomment lines and redundant and meaningless white-spaces. Afterwards we've sent the lines for a a fileParser\r\nclass, which divides it to the different scopes of the program.\r\n\r\nSince the global scope has a unique and different characterises, like the fact that its lines order are\r\nirrelevant, we've first parsed all over him to create the variables object. we understood that we dont need\r\nto store its concrete value, just some other characteristics, such as whether it was initialized, or whther\r\nthe variable was declared as a final one, and of course the type of it. we chose to store the var. object in\r\nan hashmap of the relevant scope, since the names are uniques and can served as the keys for the variable\r\nitself.Then we have created the methods objects, cause before starting to parse the inner method lines,\r\nwe add to \"recognize\" all of the method names and its invoking requirements, so we can determine wether the\r\ncode is legal.\r\n\r\n# Answers to questions \r\n\r\n### How you handled s-Java code errors in this exercise, and why you chose to do so?\r\n\r\nWe chose to implement a number of different exceptions in the different packages for different reasons, that\r\nall causes\r\nthe sjava file  to be is invalid, in any case where we detected illegal behavior of the code we called an\r\nappropriate exception for the specific error, and we added an error message describing the type of problem.\r\nAll of the exceptions we implemented inherit from the IleagalSFile exception, that we have implemented in the\r\nmain package. We chose to deal with the exceptions this way, because that in this way, way we could\r\ncharacterize each problem in the file in a unique way and print a message to the user explaining what exactly\r\nis wrong with the file. In addition, we chose to implement all the exceptions so that they would inherit from\r\nthe same class, because that each method was required to throw at most one exception, and catch only one\r\nexception in the main method.\r\n\r\n### How would you modify your code to add new types of variables (e.g., float)?\r\n\r\nvery easily - since we are guided by the single choice principle, we just had to add to the Keywords.type enum\r\nan object that fits the \"float\" string, and to update the Keywords.Type enum,to possess an additional type,which\r\nis a FLOAT for example, with its matching regex and assignments rules in the isMatching method of the enum.\r\nnow we can say we understood well the beauty within the single choice principle.\r\n\r\n### Different methods’ types:\r\n\r\nwe would send the first word to a factory of the method types, that supports just the legal method types,\r\nand stores the method type as a data member of the method object, and then when encountering a return line\r\nexpression, we would send the returned value to the method we already add, that checks if a given value is\r\nfrom a specific type.\r\n\r\n– Using methods of standard java (i.e System.out.println):\r\n\r\nwe would store them automatically as a methods of the global scope, because we know all of them at the start\r\nof the program , that's because they are fixed and could be invoked from anywhere in the file.\r\n\r\n### Please describe two of the main regular expressions you used in your code.\r\n\r\nUsing the Regex method \"CommentOrEmpty\",At the beginning of our program run in the FileParser class, we filtered\r\nout the entire line that we had to ignore and we did not add them to the list of lines we went through later\r\nin the program.\r\n\r\nUsing the Regex method \"checkMethodCall\", we checked if a valid call to the method is made in the line we are\r\nchecking, if a legal call to the method was indeed made then the method returns the name of the called method\r\nand its parameters using Matcher's \"capturing groups\" skill, and named the groups in an appropriate name,for a\r\nbetter understandability of the code.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}